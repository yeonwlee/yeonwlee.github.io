---
title: 문제풀이 - 1108. Defanging an IP Address
author: yeonwlee
date: 2024-01-31 12:48:00 +0900
categories: [Algorithm, Problem Solving]
tags: [알고리즘, 문자열, 리스트, 코딩테스트, leetcode]
---

<br>

- [문제](#문제)
- [1. 접근](#1-접근)
- [2. 제출한 답](#2-제출한-답)
  - [시간복잡도](#시간복잡도)
- [3. replace는 어떻게 동작할까?](#3-replace는-어떻게-동작할까)
- [4. r 에 대해](#4-r-에-대해)
- [5. 만약 문자열이 길거나 대체할 문자열이 많았다면?](#5-만약-문자열이-길거나-대체할-문자열이-많았다면)
  - [replace의 장단점](#replace의-장단점)
    - [장점](#장점)
    - [단점](#단점)
  - [리스트와 join 사용의 장단점](#리스트와-join-사용의-장단점)
    - [장점](#장점-1)
    - [단점](#단점-1)
  - [join](#join)

---

<br>

## 문제

![image alt 문제](/assets/img/post/2024-01-31-problemsolving-leetcode-1108-defanging-an-ip-address/img0.png)

<https://leetcode.com/problems/defanging-an-ip-address/>

## 1. 접근

replace 함수를 써서 바꿔주자.

## 2. 제출한 답

```python
class Solution:
    def defangIPaddr(self, address: str) -> str:
        return address.replace('.', r'[.]')
```

### 시간복잡도

시간 복잡도는 O(n)이다.
현 문제 조건에선 둘 다 해당되진 않지만, 대체하는 문자의 수와 대체 문자열의 크기에 따라 실행 작업에 영향을 줄 수 있다고 한다.

## 3. replace는 어떻게 동작할까?

파이썬에서, str.replace()는 문자열 내에서 특정 부분 문자열을 다른 문자열로 대체하는 기능을 제공한다.
원리는 이렇다고 한다.

-탐색: 원본 문자열을 순회

-메모리 할당: 순회 중 대상 문자열의 인스턴스를 새로운 문자열로 대체해야할 때마다, 새로운 문자열 객체에 대한 메모리를 할당한다.

-대체 작업: 원본 문자열의 일부를 새 문자열로 복사, 대체 문자열 삽입, 원본 문자열의 나머지 부분을 복사한다.
이 과정을 반복한다.

단점으론
대체해야할 문자열이 많거나, 문자열이 매우 긴 경우 메모리 할당과 문자열 복사로 인해 성능 저하가 발생할 수 있다.
이런 경우에는 리스트 사용을 고려해볼 수 있다.

해당 문제의 경우,
원래 문자보다 대체할 문자열이 길기 때문에 각 대체 작업 마다 추가적인 메모리 할당과 복사 작업이 필요하다.

## 4. r 에 대해

Raw 문자열을 뜻한다. 해당 문제에선 굳이 쓸 필요 없었다. 이스케이프 시퀀스가 문자 그대로 해석되어야 함을 나타낼 때 사용한다고 한다.
ex. '\n', '\t' 를 문자 그대로 나타낼 때

leetcode 상에서는, r이 붙은 경우와 안 붙은 경우 수행 속도에 차이가 났지만
문자열 리터럴의 raw 여부는 딱히 실행 시간에 영향을 주지 않는다고 한다.

## 5. 만약 문자열이 길거나 대체할 문자열이 많았다면?

```python
class Solution:
    def defangIPaddr(self, address: str) -> str:
        defanged = []
        for char in address:
            if char == '.':
                defanged.append('[.]')
            else:
                defanged.append(char)
        return ''.join(defanged)
```

배열을 사용했다가 join으로 마지막에 합쳐주는 식이다.

나는 주로 문자열을 다룰 일이 있으면 이 방식을 선호하긴 했는데, 그 이유는 문자열은 수정이 불가능하다는 것 때문이었다.

즉, 문자열이 변경될 시 실제 해당 문자열이 변경되는 것이 아니라 새로운 문자열이 매번 생성하는 것이기 때문에.

하지만 이것이 언제나 replace보다 좋은 방법은 아닐 수도 있다고 한다.

### replace의 장단점

#### 장점

우선 코드가 간결하고, 의도가 명확하다.
그리고 C로 구현된 내장 함수라 매우 효율적이라고 한다.
작은 규모의 문자열 변경 작업에서는 매우 빠르다고.

#### 단점

새로운 문자열을 계속 생성하기 때문에,
매우 큰 문자열이나 빈번한 변경이 필요한 경우 메모리 사용이 증가하고 성능이 저하될 수 있다.

### 리스트와 join 사용의 장단점

#### 장점

효율적인 메모리 사용. 문자열 객체를 매번 생성하지 않아도 된다.

#### 단점

코드가 더 길어지고 replace보다 덜 직관적이다.
그리고 마지막에 join이 리스트 요소들을 문자열로 결합할 때, 모든 리스트 요소를 순회하기 때문에 최종 문자열을 생성하는 데 추가적인 비용이 든다.

### join

join은 먼저 최종 문자열의 길이를 계산해서 필요한 메모리를 한 번에 할당한 후, 각 요소와 구분자를 그 메모리에 순서대로 복사하는 식으로 최종 문자열을 구성한다.
